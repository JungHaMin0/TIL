## Spring DI, IOC, Fillter, 어노테이션

### 프레임워크란?
틀 | 동작한다. 즉 틀 안에서 동작한다.

### DI란?
"의존성 주입" Dependency Injection
=> 즉 IOC에서 생성된 컨테이너 안에 오브젝트와 메소드들을 다른 곳에서 직접 가져와서 사용가능
=> '스캔' 100군데에 한 오브젝트를 가져가서 써도 스캔은 메모리에 딱 한번만 뜸
즉 IOC로 만들어진 컨테이너들을 의존성으로 인해 언제든지 오브젝트를
가져올 수 있고 코드 관리가 훨씬 더 편함.

### IoC 컨테이너란?
"제어의 역전" Inversion of Cotroll
=> 즉 주도권이 Spring에게 있다.
오브젝트의 컨테이너로서 오브젝트들을 한 곳에서 관리하고 다른 곳에 손쉽게 쓰일 수 
있게끔 되어 있는 컨테이너 

Java에서 New를 통해 같은 이름의 a일지라도 힙에 새롭게 저장이 돼서 메모리 공간 낭비도 심하고 관리가 제로
하지만 Spring은 의자, 기린, 책상 이런 것들을 컨테이너로 한번에 모아서 DI를 할 때 내보낸다.

*중요핵심
DI와 IOC를 확실하게 알아야 개발이 쉬워진다.


### Fillter란?
접근을 제어하는 문지기.
A나라와 B나라가 있다고 치면 B나라가 A나라로 들어갈 때
인터셉터처럼 막아줄 수 있는 필터.

### 어노테이션이란?
주석 <-- 컴파일러가 무시!
어노테이션 <-- 컴파일러가 무시하지 않는다!
사용용도: @Override처럼 부모와 자식의 메소드 체킹

@Compont: 클래스 메모리에 로딩
@Autowired: 로딩된 객체를 해당변수에 집어넣어

*Java와 Spring
[Java]
A a = new A(); --> 이것은 힙 메모리 공간에 새롭게 생성이 됨.

[Spring]
A a; --> 힙 메모리 공간에 새롭게 생성하지 않고 생성된 A를 가져옴.
이 때 @Autowired를 붙여줘야한다.
여기서 중요한게 @Autowired로 A a;를 가져올 때 그 때 DI가 쓰임. 힙에서 가져오니깐.

